# 학습 체크리스트

- [x] 함수형 프로그래밍 온보딩
- [x] 코딩의 기술 3장

# 학습 내용

## 1️⃣ 함수형 프로그래밍 기초

미션을 클래스를 사용하여 코드를 구성했습니다. 하지만 프론트엔드에서 함수형 프로그래밍을 많이 사용한다 하였으며 미션에서도 로직 자체는 메소드를 통해 진행되기 때문에 함수형 프로그래밍을 공부하면 좋을 것 같아서 시작했습니다. 하지만 제가 생각했던 함수가 함수형 프로그래밍에서 함수가 다른 의미였습니다. 함수는 단순히 기능이 아니라 정말 수학적인 의미에서 함수를 뜻합니다. 그렇기 때문에 함수형 프로그래밍은 기존에 생각했던 절차지향적인 방식과는 완전히 다르다고 합니다.

### 순수성

- 외부 변수를 수정할 수 없습니다.
- 언제 실행하더라도 매개변수가 같으면 같은 결과값을 나타내어야 합니다.

### 불변성

- 함수형 프로그래밍에서는 변수가 없습니다. 계산된 값을 다시 변수에 집어 넣는 방식의 연속입니다. (수학식에 배운 함수를 생각해보라고 합니다.)
- for, while 등 특정 방복문 구조를 사용하지 않습니다. 대신에 주로 재귀함수를 사용합니다.

### 리팩토링

- 클래스는 주체를 기준으로, 함수형은 동작을 기준으로 리팩토링합니다.
- a함수와 b함수가 동작은 같고 대상만 다르다면 대상을 인자로 받는 함수를 만들어 활용도를 높일 수 있습니다.

### 고차함수

- 자바스크립트의 함수는 일급객체 입니다. 따라서 함수를 인자로, return값으로 사용할 수도 있습니다.

### 클로저

- 클로저는 참조에 의해 반환 이후에도 계속 lexical scope를 갖고 있는 것을 의미합니다.
- **개념적으로는 이해가 가지만, 어떻게 활용할 수 있을지는 잘 모르겠습니다.**

### 합성함수

- 함수의 결과값을 다른 함수의 인자로 받는 형태를 의미합니다.
- g(h(s(r(t(x))))) 이런 식으로 표현되며 이럴 경우 괄호 때문에 가독성을 해칠 수 있습니다.

### Point-Free

- g(h(s(r(t(x))))) 가 복잡해보여도 여전히 좋은 이유는 불필요한 변수를 선언하지 않아도 되기 때문입니다.계산된 값을 바로 인자로 넘겨줍니다. 이를 Point-Free방식이라 합니다.
- 하지만 함수 f(x) 와 g(x)를 합성하는데 하나는 인자를 2개를 받고, 하나는 인자를 1개만 받는다면 이는 더이상 합성함수가 아니라고 합니다. 이러한 문제를 해결하기 위해 필요한 것이 커링입니다.

### 커링

- 두 개의 인자를 받는 함수를 하나의 인자를 받는 함수로 수정할 수 있습니다.
  ```jsx
  var add = (x) => (y) => x + y;
  ```
  이처럼 하나의 변수를 받았을 때 새로운 함수를 반환합니다. 그리고 그 함수에서 두번째 변수를 받을 수 있게 만드는 것입니다.
  즉, f(a, b) 에서 f(a)(b)로 변경할 수 있습니다. 물론 하나의 변수만 넣었을 때를 저장하여 결국 하나의 매개변수만 받는 함수로서 사용도 가능합니다.

### map, filter, reduce

- 이 함수들의 가장 큰 특징은 루프가 없고 재귀적으로 값을 반환한다는 것입니다.
- 예제에서는 단순히 배열 메소드가 아니라 직접 함수를 만들어서 사용했는데 이유를 알아보니 해당 문법이 존재하지 않았을 때 이렇게 사용했다고 합니다. 그리고 지금도 이렇게 사용하는 이유는 배열뿐만 아니라 모든 이터러블 객체에 적용할 수 있기 때문이라고 합니다.

### 참조투명성

- 해당 챕터는 블로그 글이 이해가 되지 않아 추가로 찾아봤습니다. 함수가 외부에 영향을 주는 것을 사이드 이팩트라고 한다면, 함수가 외부의 영향을 받는다는 것은 참조 투명성을 해치는 일입니다.
- IO, URL, DB, 파일 시스템 등에서 데이터를 읽지 않아야 한다고 합니다.
- 멀티스레드 환경에서 병렬계산에 함수형이 유리하기 때문에 코드 실행과정에서 블락되는 부분을 피하라는 말인 것 같습니다.

🔗 참고자료

| 제목              | 링크                                                                                                 |
| ----------------- | ---------------------------------------------------------------------------------------------------- |
| 함수형 프로그래밍 | https://soojae.tistory.com/29                                                                        |
| 참조투명성        | https://jinwooe.wordpress.com/2017/12/21/부수-효과-side-effect-참조-투명성-referential-transparency/ |

## 2️⃣ 자바스크립트 코딩의 기술 3장

### 3장: 특수한 컬렉션을 이용해 코드 명료성을 극대화하라

ES6 이후 배열과 객체뿐만 아니라 Map, Set, weakMap, weakSet 등 다양한 컬렉션 객체가 생긴 걸로 알고 있습니다. 우테코 프리코스를하면서 Map과 Set 도 정리를 했었는데, Map은 어느정도 이해가 되었지만 Set을 굳이 왜 사용하는지(중복 제거하기 위한 용도를 제외하고) 의문이었습니다. 더 명료하게 경우에 따라 사용하면 좋은 컬렉션이 무엇인지 생각해볼 수 있었습니다. 또한 앞부분에서는 객체를 더 깊게 이해할 수 있었습니다.

- **스프레드 연산자로 객체 정보를 갱신해라**
  앞서 2장에서 배열을 공부했을 때 원본이 조작되는 것을 방지하기 위한 노력을 공부했습니다. 객체 역시 마찬가지입니다. 객체 역시 스프레드 연산자가 제공되기 때문에 이를 이용하여 정보를 조작하여 원본이 훼손되는 것을 막아야합니다.
  ```jsx
  const personDefault = {
    name: '',
    age: 17,
    country: 'Korea',
    city: '',
  };

  const ukko = {
    name: 'ukko',
    country: 'SouthKorea',
  };

  const update = { ...personDefault, ...ukko }; //{ name: 'ukko', age: 17, country: 'SouthKorea', city: '' }
  ```
- **맵을 사용하여 키-값 데이터를 갱신하라**
  맵을 사용하는 이유는 두 가지가 있습니다.
  1. 키-값 쌍이 자주 추가되거나 삭제되는 경우
  2. 키가 문자열이 아닌 경우
  하지만 제가 이제껏 Map 객체가 갖는 장점에 대해 알고 있지만 잘 사용하지 않았던 이유는 value값 조작이 불편하기 때문입니다. `map.set(map.get(’ukkoAge’), map.get(’ukkoAge’) + 3` 이런 식으로 해야하기 때문입니다. 그 외에도 값을 추가할 때마다 .set()으로 해야하고 초기값을 지정할 때 객체는 불가능하고 2차원 배열을 사용해야한다는 것이 불편했습니다.
  이 파트를 읽고 나서 그럼에도 위의 조건만 맞으면 객체보다 Map을 사용하는 이유는 이렇습니다.
  1. 객체와 다르게 이터레이터이며 맵이터레이터의 활용도가 굉장히 높다.

  2. 앞서 말한 불편한 사항은 helper함수를 정의하여 사용하면 된다.
- **맵과 펼침 연산자로 키-값 데이터를 순회하라**
  ```jsx
  const testMap = new Map([
    [1, 'a'],
    [3, 'b'],
    [2, 'c'],
  ]); //Map { 1 => 'a', 3 => 'b', 2 => 'c' }

  const newMap = new Map([...testMap].sort()); //Map { 1 => 'a', 2 => 'c', 3 => 'b' }
  ```
  new Map 객체 인스턴스를 생성할 때 2차원 배열을 인자로 받아 키-값 형태를 초기화할 수 있습니다. 또한 스프레드 연산자를 사용하면 다시 2차원 배열로 만들 수 있습니다. 배열에서 제공하는 메소드들을 자유롭게 사용할 수 있다는 뜻입니다.
  또한, `.keys()`, `.values()`, `.entries()` 메소드를 통해 이터러블 객체를 사용할 수 있으며 Map객체 자체가 이터러블이기 때문에 for…of… 문을 사용하여 순회할 수 있습니다.
- **세트를 이용해 고윳값을 관리하라**
  세트를 사용하는 이유: 고유값만 분류해내야 하는 경우입니다.
  역시 제가 느꼈던 대로 세트의 활용도가 다른 언어 비해 많은 것 같진 않습니다.
  그리고 깨달았던 점은 단순히 배열의 요소의 중복을 제거하는 목적 외에도 더 복잡한 자료구조에서도 중복을 제거할 수 있었다는 점입니다.
  ```jsx
  const dogs = [
  	{
  		색상: ,
  		이름: ,
  	//...
  	},
  	{

  	},

  	//...
  ];

  [...dogs.reduce((colors, {색상}) => colors.add(색상), new Set())]
  ```
  1. reduce의 초기값을 Set()으로 둡니다.
  2. dogs배열을 순회하면서 해당 객체의 색상 프로퍼티에 접근하여 Set에 더합니다.
  3. 그렇게 반환된 Set를 배열로 변환해줍니다.

# 회고

## 1️⃣ 배운 점

1. 기능 완성을 완료한 것 같습니다. 이보다 뿌듯한 일은 없을 겁니다. 하지만 저는 알고 있습니다. 다시 리팩토링을 해야한다는 것을요… 왜냐하면 기존에 주어진 테스트 코드는 통과를 하지 않기 때문입니다. 몇가지 손을 본 상황이지만 더 확인해 봐야할 것 같습니다!
2. 한 크루분께서 함수형 프로그래밍에 대해 올려준 게 있어서 정리를 해봤습니다. 합성함수에 대해 제대로 알게 되어서 좋았습니다. 나름 함수형으로 작성한다고 했던 제 코드들에서 어떤 문제가 있었는지 알 수 있었습니다.

## 2️⃣ 배울 점

1. 내일은 저번주에 미처 못한 정규표현식을 discussion에 올릴 것입니다.
2. 코드를 반복 읽으면서 리팩토링할 수 있는 부분을 찾아봐야할 것 같습니다.
