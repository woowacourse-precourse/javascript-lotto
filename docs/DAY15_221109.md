# 학습 체크리스트

- [x] 공통 피드백
- [x] this

# 학습 내용

## 1️⃣ 공통 피드백

### 1. 구현 순서도 코딩 컨벤션이다.

피드백 내용처럼 클래스의 순서는 필드, 생성자, 메서드입니다. 그것은 알겠지만 메서드 사이에서도 어떤 순서를 갖고 있어야 좋은 것인지 항상 고민이되는 것 같습니다. 최대한 메소드 내에서 다른 메소드가 호출되는 경우는 그 메소드 아래에다가 선언하는 편입니다. 다른 방법은 없는지 찾아보고 스스로 느껴봐야할 것 같습니다.

### 2. 함수가 한 가지 기능만 하는지 확인하는 기준을 세운다.

함수 길이가 15라인을 넘지 않는 것은 최소한의 기준 같습니다. 단순히 15줄을 넘지 않는다고 해서 해당 함수가 한 가지 기능만 한다고 장담할 순 없을 것 같습니다. 계속 반복해서 읽고 적절한 기능을 하고 있는지 그리고 그러한 네이밍을 하였는지, 그리고 다시 네이밍에 맞는 코드가 한 가지 기능만 하는지 지속적으로 검토해볼 필요가 있을 것 같습니다.

### 3. 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다.

2주차 미션에서 테스트를 제대로 작성하지 않았음에도 구현하는 데 벅찬 미션이었습니다. 3주차 미션은 더 복잡해 보이기 때문에 이번에도 테스트는 구현 후에 해야할 것 같습니다. (포비님이 말씀하신 것처럼 자신의 걸음대로 가라는 걸 명심하고!) 그렇게 된다면 피드백에서 말씀 주신 “단지 기능을 점검하기 위한 목적으로 테스트를 작성하는 것은 아니다.” 라는 말의 본 의미를 제대로 확인하긴 어려울 수도 있겠다는 생각이 들었습니다. 이미 구현을 다 한 뒤에 테스트 코드를 작성하는 것은 기능 점검만 하는 것이 아닐까 라는 지레 짐작입니다. 이 역시 테스트 코드를 공부하고 적용해보면서 느껴봐야할 것 같습니다.

## 2️⃣ this binding

this는 자바스크립트를 사용하면서 예측하기 어려운 존재입니다. 때로는 메소드 안에서 또 다른 콜백함수에서 사용되는 this는 정말 헷갈리곤 합니다. 또한 화살표함수랑 그냥 함수에서도 this 바인딩이 달라서 혼란이 더 가중됩니다. 때문에 해당 함수에서 사용되는 this를 분명히 정해둘 수 있는 문법이 있습니다. `bind()` `call()` `apply()` 입니다.

### bind()

bind()는 태생이 call()과 apply()와 조금 다릅니다. bind()는 함수를 선언할 때 this를 원하는 데이터에 바인딩 해주는 역할을 합니다. (반면에 call, apply는 호출할 때 this binding이 이뤄집니다.)

```jsx
const module = {
  x: 42,
  getX: function () {
    return this.x;
  },
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42
```

해당 코드는 MDN의 예제 코드입니다. **this는 선언이 아닌 호출 시에 바인딩이 이뤄집니다.** 때문에 gexX 메소드를 bind없이 호출하여 새로운 변수에 선언한다면 해당 this는 호출 시점인 global scope의 window혹은 global을 가르킬 겁니다. module 객체의 메소드였음에도 말이죠.

이러한 버그를 없애기 위해 가장 확실한 방법은 bind를 하는 것입니다. bind를 하게 될 경우 this는 module객체를 가르키게 됩니다.

만약 이와 같이 this가 window/global 을 가르키는 것을 피하시고 싶으면 `‘use strict’` 을 설정하는 것도 방법입니다. 엄격 모드에서는 전역 객체의 값을 Window 대신 undefined로 설정하기 때문에 this의 메소드나 프로퍼티에 접근할 때 에러를 발생시킵니다.

### call()

`func.call(thisArg[, arg1[, arg2[, ...]]])`

call()은 apply()와 마찬가지로 함수를 호출 할 때 this를 바인딩하여 사용 가능합니다. 둘의 가장 큰 차이는 apply는 call과 다르게 함수의 인자를 배열로 받습니다.

call()함수의 첫 번째 parameter은 this가 바인딩할 객체를 받습니다. 그리고 두 번째부터는 원래 함수에서 받아야할 인자를 받으면 됩니다.

```jsx
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = 'food';
}

console.log(new Food('cheese', 5).name);
// expected output: "cheese"
```

Food 함수에서 실행된 `Product.call(this, name, price)` 에 집중해보겠습니다. Product 함수를 실행하는데 Product에서 사용되는 this를 Food로 바인딩합니다. 그리고 Food에서 받은 name과 price를 그대로 인자로 받아서 실행시킨 것입니다.

어디서 많이 본 로직 같지 않나요. 찾아보니 클래스 문법이 나오기 전 생성자 함수에서 상속 관계를 표현할 때 이렇게 call()을 사용했다고 합니다.

### apply()

apply()는 call()과 같지만 인자를 배열로 받는다는 것 외에는 차이가 없습니다.

```jsx
function Food(name, price) {
  Product.apply(this, [name, price]);
  this.category = 'food';
}
```

위의 예시에서 이렇게 배열로 받는다면 apply를 사용하면 정확히 같은 기능을 하는 코드가 될 것입니다.

🔗 참고자료

| 제목    | 링크                                                                                         |
| ------- | -------------------------------------------------------------------------------------------- |
| bind()  | https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind  |
| call()  | https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call  |
| apply() | https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply |

# 회고

## 1️⃣ 배운 점

1. 클래스를 많이 사용, 메소드 내에서도 콜백함수(readLine) 등을 많이 사용하다보니 계속 this가 예상과는 다른 결과를 참조하게 되는 버그가 일어났습니다. 이 참에 this, bind, call, apply 를 보면서 어떻게 this를 핸들링할 지 배울 수 있었습니다. 그러나 아직 bind밖에 잘 활용을 못하겠는데 기회가 된다면 하나씩 적용해보고 싶습니다.

## 2️⃣ 배울 점

1. 우선은 구현에 힘을 써야할 것 같습니다. 미션에서 제시한 것도 지키면서 공부하면 좋겠지만 저의 속도와 실력에 맞는 공부가 우선인 것 같습니다. 빠르게 구현 먼저 해보고 테스트 코드를 작성하면 좋을 것 같습니다!
