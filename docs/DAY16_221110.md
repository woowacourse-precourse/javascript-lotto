# 학습 체크리스트

- [x] 크루 코드 공부하기
- [x] try catch 예외 핸들링
- [x] 코딩의 기술 1,2장

# 학습 내용

## 1️⃣ Array.from()

에어비엔비 자바스크립트 컨벤션에 따르면 이터러블 객체의 경우 array로 만들 때 Array.from() 보다는 …스프레드 연산자를 사용하는 것을 권장했습니다. 하지만 다른 크루분의 2주차 코드를 보면서 놀라운 것을 발견했는데 Array.from()의 두 번째 인자로 콜백을 받을 수 있다는 사실입니다. 그리고 그 콜백은 map을 실행한 것과 같은 효과였습니다.

```jsx
const testString = 'test';
const testArray = Array.from(testString, (char) => char.toUpperCase()); //[ 'T', 'E', 'S', 'T' ]
```

이터러블 객체를 배열로 변환하는 과정에서 추가 연산 과정이 있을 경우 사용하면 좋을 것 같습니다.

🔗 참고자료

| 제목         | 링크                                                                                     |
| ------------ | ---------------------------------------------------------------------------------------- |
| Array.from() | https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from |

## 2️⃣ try…catch…

2주차부터 계속 예외처리하는 것에 문제가 있었습니다. 이것 저것 시도해보면서 시행착오 끝에 결국 원하는 코드를 작성할 수는 있었지만 제대로 원리를 파악하지 못 했던 것 같습니다.

분명 실행문에서 error을 발생시키고 try catch 구문을 사용하면 프로그램이 멈추지 않는 것인지 그것이 너무 궁금했습니다. (try catch에서 프로그램을 정지시키려면 다시 catch에서 에러를 발생시켜야 합니다.)

mdn문서에서는 try catch 활용 방법에 대한 내용만 있어서 다른 자료를 찾아보았습니다. JAVASCRIPT.info에 따르면 **try catch 구문을 사용하는 것은 스크립트 프로그램이 에러로 인해 멈추는 것을 막기 위함**에 있다고 합니다. 즉, 사실 제 의도는 에러가 발생하면 프로그램이 죽어야하는데 try catch는 그렇지 않게 해주는 도구였던 것입니다.

정리하면 다음과 같이

`throw new Error(e)` → `try { } catch (e) { throw new Error(e) }`

미션에서는 굳이 try catch 를 사용해서 에러를 두 번 발생시켜서 프로그램을 종료할 필요는 없을 것 같습니다.

🔗 참고자료

| 제목       | 링크                                 |
| ---------- | ------------------------------------ |
| try…catch… | https://ko.javascript.info/try-catch |

## 3️⃣ 자바스크립트 코딩의 기술 1, 2장

저번주에 모던 자바스크립트 가이드라는 책을 읽으면서 아직도 자바스크립트에 대해 모르는 것이 많다는 생각이 들었습니다. 책을 읽으면서 얻은 내용을 미션에 적용하여 더 좋은 코드를 만들었던 경험이 있어서 “자바스크립트 코딩의 기술”이라는 책을 샀습니다. 자바스크립트 사용에 대한 작은 팁들로 이뤄진 책이기 때문에 가볍게 볼 수 있을 것 같아서 선정했습니다.

### **1장: 변수 할당으로 의도를 표현하라**

1장은 이번 미션을 하면서 피드백에서도 그렇고, 구글링으로 클린코드를 검색했을 때 많이 나오던 내용이어서 편하게 읽을 수 있었습니다.

- **const를 사용하여 예측 가능한 값을 표현하기**
  let보다 const를 더 사용해야하는 이유가 있습니다.
  ```jsx
  let taxRate = 0.1;
  let total = 100 + 100 * taxRate;
  //100줄 뒤
  console.log(total);
  ```
  let을 사용하면 원시 데이터는 언제든 변할 수 있습니다. 즉, taxRate와 total 변수의 값이 변할 수 있다는 뜻입니다. 100줄 뒤에 total값이 무엇이 될지 예측하기 힘들어집니다. 따라서 total 값을 예측하려면 total이 선언된 뒤 어떻게 값이 변했는지 하나씩 다 뜯어봐야할 것입니다. 이런 불편을 막기 위해 const를 사용하여 예측 가능하게끔 코드를 짜는 것이 최선입니다.

### 2장: 배열로 데이터 컬렉션을 관리하라

자바스크립트에서 배열은 아주 강력한 메소드들을 제공합니다. 조작이 쉬워 유연하게 다른 자료구조로 변경할 수 있습니다. 하지만 이는 장점이자 단점이 될 수도 있습니다. 이 책에선 배열을 비롯한 모든 자료를 다룰 때 원본 값이 변경되는 것을 경계해야한다고 합니다.

- **indexOf() 보다는 Includes()로 존재 여부를 확인하라**
  ```jsx
  const arr = [1, 2, 3, 4, 5];
  if (arr.indexOf(1)) {
    //...
  }
  ```
  다음 if문은 실행되지 않습니다. 왜냐하면 arr.indexOf(1)의 반환값은 인덱스 0입니다. 그리고 0은 falsy값입니다. 이러한 단점을 해결하기 위해 나온 것이 includes()입니다. 배열에 해당 요소가 있는지 확인하는 메소드를 통해 정확하게 조건을 정해줄 수 있스빈다.
- **펼침 연산자로 배열을 본 떠라**
  ```jsx
  const arr = [5, 2, 1, 4, 3];

  const push6 = (arr) => {
    arr.push(6);
    return arr;
  };

  const sortArr = (arr) => {
    arr.sort();
    return arr;
  };

  const newArr1 = push6(arr); //[ 5, 2, 1, 4, 3, 6 ]

  const newArr2 = sortArr(arr); //[ 1, 2, 3, 4, 5, 6 ]

  arr; //[ 1, 2, 3, 4, 5, 6 ]
  ```
  기존에 있던 배열에 6을 더한 배열을 구하고, 또 정렬한 배열을 따로 구했습니다. 하지만 원본 배열인 arr도 덩달아서 변경된 것을 확인할 수 있습니다. 이렇듯 자바스크립트의 메소드 중 일부는 원본 데이터를 변경시킵니다. 이러한 혼란을 줄이기 위해 반드시 복사본을 가공 후 리턴하는 함수를 정의해야 합니다.
  ```jsx
  //대안1
  const push6 = (arr) => {
    const newArr = [...arr];
    arr.push(6);
    return arr;
  };

  //대안2
  const push6 = (arr) => [...arr, 6];
  ```
  이렇게 작성하면 원본 훼손없이 원하는 배열을 얻을 수 있습니다. push나 sort 외에도 대표적으로 조심해야할 배열 메소드에는 splice()와 concat()이 있습니다.

# 회고

## 1️⃣ 배운 점

1. 다른 사람의 코드를 보면서 좋은 점은 제가 익숙했던 코드 작성 방식에서 다른 시야를 보게 해주는 것 같습니다. Array.from()이 그렇습니다. 또한 동시에 왜 코드에는 정답이 없다고 하는지도 조금씩 알게된 하루였습니다. 컨벤션은 말 그대로 지켰으면 하는 규칙이지, 그것이 정답은 아니라는 것입니다. 스프레드 연산자 대신에 Array.from()을 사용함으로써 더 map 메소드를 굳이 사용하지 않아도 되는 장점도 있으니까요!
2. 생각보다 2주차까지 공부하면서 배운 내용이 실력 향상에 도움이 되었던 것 같습니다. 3주차 미션을 받았을 때 어렵게만 느껴졌는데 막상 코드를 작성하다보니 생각보다 나름? 잘 구현하고 있는 제 모습을 볼 수 있었습니다.

## 2️⃣ 배울 점

1. 앞으로도 미션을 하면서 시간이 부족할 수도 있지만 일정하게 인풋을 충당해야겠다 생각했고 그것이 책입니다. 이번주 목표는 자바스크립트 코딩의 기술을 다 보는 것입니다.
2. 빠르게 구현을 마무리하고 싶습니다. 오늘 생각보다 잘했기 때문에 내일이면 기능은 다 구현할 수 있을 것 같다는 생각이 듭니다.
