# 이 프로젝트 소개

[홈에서 보기](/README.md)

# 명세서

3주 차 미션에서는 2주 차에서 학습(함수 분리와 함수별로 테스트를 작성)한 것에 2가지 목표를 추가됨!

- [x] 클래스(객체)를 분리하는 연습

- [x] 도메인 로직에 대한 단위 테스트를 작성하는 연습


- [x] README.md를 상세히 작성한다. 해당 프로젝트가 어떠한 프로젝트이며, 어떤 기능을 담고 있는지 기술한다.

- [x] 기능 목록을 재검토한다. 기능 목록을 클래스 설계와 구현, 함수(메서드) 설계와 구현과 같이 너무 상세하게 작성하지 않는다. 
클래스 이름, 함수(메서드) 시그니처와 반환값은 언제든지 변경될 수 있기 때문이다. 너무 세세한 부분까지 정리하기보다 구현해야 할 기능 목록을 정리하는 데 집중한다. 정상적인 경우도 중요하지만, 예외적인 상황도 기능 목록에 정리한다. 특히 예외 상황은 시작 단계에서 모두 찾기 힘들기 때문에 기능을 구현하면서 계속해서 추가해 나간다. 기능 목록을 업데이트한다 README.md 파일에 작성하는 기능 목록은 기능 구현을 하면서 변경될 수 있다. 시작할 때 모든 기능 목록을 완벽하게 정리해야 한다는 부담을 가지기보다 기능을 구현하면서 문서를 계속 업데이트한다. 죽은 문서가 아니라 살아있는 문서를 만들기 위해 노력한다.

- [x] 값을 하드 코딩하지 않는다. 문자열, 숫자 등의 값을 하드 코딩하지 마라. 상수를 만들고 이름을 부여해 이 변수의 역할이 무엇인지 의도를 드러낸다.

- [x] 구현 순서도 코딩 컨벤션이다.클래스는 필드, 생성자, 메서드 순으로 작성한다.

    class A {
        필드

        생성자

        메서드
    }

- [x] 한 함수가 한 가지 기능만 담당하게 한다. 함수 길이가 길어진다면 한 함수에서 여러 일을 하려고 하는 경우일 가능성이 높다. 아래와 같이 한 함수에서 안내 문구 출력, 사용자 입력, 유효값 검증 등 여러 일을 하고 있다면 이를 적절하게 분리한다.

    const userInput = () => {
    MissionUtils.Console.print("숫자 야구 게임을 시작합니다.");
    MissionUtils.Console.readLine("숫자를 입력해 주세요: ", (input) => {
        const userNumbers = input.split(",");
        if (userNumbers.length !== 3) {
        throw new Error("[ERROR] 숫자가 잘못된 형식입니다.");
        }
    });
    };

- [x] 함수가 한 가지 기능을 하는지 확인하는 기준을 세운다. 만약 여러 함수에서 중복되어 사용되는 코드가 있다면 함수 분리를 고민해 본다. 

- [x] 또한, 함수의 길이를 15라인을 넘어가지 않도록 구현하며 함수를 분리하는 의식적인 연습을 할 수 있다.

- [x] JavaScript에서 객체를 만드는 다양한 방법을 이해하고 사용한다. JavaScript에서는 클래스 말고도 객체를 만드는 방법은 여러 가지가 있다. 객체를 생성하는 방법에 대해서는 MDN 문서의 JavaScript 객체 기본과 Classes을 참고한다.

- [x] 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다. 단지 기능을 점검하기 위한 목적으로 테스트를 작성하는 것은 아니다. 테스트를 작성하는 과정을 통해서 나의 코드에 대해 빠르게 피드백을 받을 수 있을 뿐만 아니라 학습 도구(학습테스트를 통해 JUnit 학습하기.pdf)로도 활용할 수 있다. 이런 경험을 통해 테스트에 대해 어떤 유용함을 느꼈는지 알아본다.

- [x] 처음부터 큰 단위의 테스트를 만들지 않는다. 테스트의 중요한 목적 중 하나는 내가 작성하는 코드에 대해 빠르게 피드백을 받는 것이다. 시작부터 큰 단위의 테스트를 만들게 된다면 작성한 코드에 대한 피드백을 받기까지 많은 시간이 걸린다. 그래서 문제를 작게 나누고, 그 중 핵심 기능에 가까운 부분부터 작게 테스트를 만들어 나간다.

    큰 단위의 테스트
    숫자 야구 게임을 시작해서 사용자가 숫자를 입력하면, 컴퓨터 숫자와 비교하여 그 결과를 알려준다.

    작은 단위의 테스트
    사용자의 숫자가 컴퓨터의 숫자와 하나도 일치하지 않으면 낫싱을 출력한다.
    사용자의 숫자가 컴퓨터의 숫자와 1개는 일치하고, 위치가 다르면 1볼을 출력한다.




## 🚀 기능 요구 사항

로또 게임 기능을 구현해야 한다. 로또 게임은 아래와 같은 규칙으로 진행된다.

- [x] 로또 번호의 숫자 범위는 1~45까지이다. //generateRandomNumbers()
    - [x] 테스트 완료

- [x] 1개의 로또를 발행할 때 중복되지 않는 6개의 숫자를 뽑는다. //generateRandomNumbers()
    - [x] 테스트 완료

- [x] 당첨 번호 추첨 시 중복되지 않는 숫자 6개와 보너스 번호 1개를 뽑는다. //setLottoNumbers(), setBonusNumber()
    - [x] 테스트 완료

- [x] 당첨은 1등부터 5등까지 있다. 당첨 기준과 금액은 아래와 같다. //figureLotteryRewards()
    - [x] 1등: 6개 번호 일치 / 2,000,000,000원
      - [x] 테스트 완료
    - [x] 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
      - [x] 테스트 완료
    - [x] 3등: 5개 번호 일치 / 1,500,000원
      - [x] 테스트 완료
    - [x] 4등: 4개 번호 일치 / 50,000원
      - [x] 테스트 완료
    - [x] 5등: 3개 번호 일치 / 5,000원
      - [x] 테스트 완료

- [x] 로또 구입 금액을 입력하면 구입 금액에 해당하는 만큼 로또를 발행해야 한다.
    - [x] 테스트 완료
- [x] 로또 1장의 가격은 1,000원이다. //TICKET_PRICE
- [x] 당첨 번호와 보너스 번호를 입력받는다.
- [x] 사용자가 구매한 로또 번호와 당첨 번호를 비교하여 당첨 내역 및 수익률을 출력하고 로또 게임을 종료한다.
    - [x] 테스트 완료
- [x] 사용자가 잘못된 값을 입력할 경우 `throw`문을 사용해 예외를 발생시키고, "[ERROR]"로 시작하는 에러 메시지를 출력 후 종료한다.

### 입출력 요구 사항

#### 입력

- [x] 로또 구입 금액을 입력 받는다. 구입 금액은 1,000원 단위로 입력 받으며 // validateMoney()

- [x] 1,000원으로 나누어 떨어지지 않는 경우 예외 처리한다. // validateMoney()

```
14000
```

- [x] 당첨 번호를 입력 받는다. 번호는 쉼표(,)를 기준으로 구분한다. // setLottoNumbers()

```
1,2,3,4,5,6
```

- [x] 보너스 번호를 입력 받는다. //  setBonusNumber()

```
7
```

#### 출력

- [x] 발행한 로또 수량 및 번호를 출력한다. 로또 번호는 오름차순으로 정렬하여 보여준다. //generateTickets()

```
8개를 구매했습니다.
[8, 21, 23, 41, 42, 43]
[3, 5, 11, 16, 32, 38]
[7, 11, 16, 35, 36, 44]
[1, 8, 11, 31, 41, 42]
[13, 14, 16, 38, 42, 45]
[7, 11, 30, 40, 42, 43]
[2, 13, 22, 32, 38, 45]
[1, 3, 5, 14, 22, 45]
```

- [x] 당첨 내역을 출력한다. //calculateTickets()

```
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개
```

- [x] 수익률은 소수점 둘째 자리에서 반올림한다. (ex. 100.0%, 51.5%, 1,000,000.0%)
  - [x] 테스트 완료

```
총 수익률은 62.5%입니다. //calculateProfits()
```

- [x] 예외 상황 시 에러 문구를 출력해야 한다. 단, 에러 문구는 "[ERROR]"로 시작해야 한다.

```
[ERROR] 로또 번호는 1부터 45 사이의 숫자여야 합니다.
```

#### 실행 결과 예시

```
구입금액을 입력해 주세요.
8000

8개를 구매했습니다.
[8, 21, 23, 41, 42, 43]
[3, 5, 11, 16, 32, 38]
[7, 11, 16, 35, 36, 44]
[1, 8, 11, 31, 41, 42]
[13, 14, 16, 38, 42, 45]
[7, 11, 30, 40, 42, 43]
[2, 13, 22, 32, 38, 45]
[1, 3, 5, 14, 22, 45]

당첨 번호를 입력해 주세요.
1,2,3,4,5,6

보너스 번호를 입력해 주세요.
7

당첨 통계
---
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개
총 수익률은 62.5%입니다.
```

---

## 🎯 프로그래밍 요구 사항

- [x] Node.js 14 버전에서 실행 가능해야 한다. **Node.js 14에서 정상적으로 동작하지 않을 경우 0점 처리한다.**

- [x] 프로그램 실행의 시작점은 `App.js`의 `play` 메서드이다. 아래와 같이 프로그램을 실행시킬 수 있어야 한다.

**예시**

```javascript
const app = new App();
app.play();
```

- [x] `package.json`을 변경할 수 없고 외부 라이브러리(jQuery, Lodash 등)를 사용하지 않는다. 순수 Vanilla JS로만 구현한다.

- [x] [JavaScript 코드 컨벤션](https://github.com/woowacourse/woowacourse-docs/tree/main/styleguide/javascript)을 지키면서 프로그래밍 한다

- [x] 프로그램 종료 시 `process.exit()`를 호출하지 않는다.

- [x] 프로그램 구현이 완료되면 `ApplicationTest`의 모든 테스트가 성공해야 한다. **테스트가 실패할 경우 0점 처리한다.**

- [x] 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 이름을 수정하거나 이동하지 않는다.

- [x] indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
  - [x] 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
  - [x] 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메서드)를 분리하면 된다.

- [x] 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.

- [x] Jest를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.

### 추가된 요구 사항

- [x] 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
  - [x] 함수(또는 메서드)가 한 가지 일만 잘 하도록 구현한다.

- [x] else를 지양한다.
  - [x] 힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
  - [x] 때로는 if/else, switch문을 사용하는 것이 더 깔끔해 보일 수 있다. 어느 경우에 쓰는 것이 적절할지 스스로 고민해 본다.

- [x] 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(Console.readLine, Console.print) 로직에 대한 단위 테스트는 제외한다.
  - [x] 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 구분한다.
  - [x] 단위 테스트 작성이 익숙하지 않다면 `__tests__/LottoTest.js`를 참고하여 학습한 후 테스트를 구현한다.
